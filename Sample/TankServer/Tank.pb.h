// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Tank.proto

#ifndef PROTOBUF_Tank_2eproto__INCLUDED
#define PROTOBUF_Tank_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Tank {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Tank_2eproto();
void protobuf_AssignDesc_Tank_2eproto();
void protobuf_ShutdownFile_Tank_2eproto();

class Login;
class Message;
class MessageHeader;
class Message_CharacterState;
class RoomState;
class Vec2;
class Vec3;
class Vec4;

enum Message_CharacterState_ActionID {
  Message_CharacterState_ActionID_NONE = 0,
  Message_CharacterState_ActionID_MOVEACTION = 1,
  Message_CharacterState_ActionID_ROTATIONACTION = 2,
  Message_CharacterState_ActionID_TURRETROTATIONACTION = 3,
  Message_CharacterState_ActionID_FIREACTION = 4
};
bool Message_CharacterState_ActionID_IsValid(int value);
const Message_CharacterState_ActionID Message_CharacterState_ActionID_ActionID_MIN = Message_CharacterState_ActionID_NONE;
const Message_CharacterState_ActionID Message_CharacterState_ActionID_ActionID_MAX = Message_CharacterState_ActionID_FIREACTION;
const int Message_CharacterState_ActionID_ActionID_ARRAYSIZE = Message_CharacterState_ActionID_ActionID_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_CharacterState_ActionID_descriptor();
inline const ::std::string& Message_CharacterState_ActionID_Name(Message_CharacterState_ActionID value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_CharacterState_ActionID_descriptor(), value);
}
inline bool Message_CharacterState_ActionID_Parse(
    const ::std::string& name, Message_CharacterState_ActionID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_CharacterState_ActionID>(
    Message_CharacterState_ActionID_descriptor(), name, value);
}
enum Message_ID {
  Message_ID_UNKNOWN = 0,
  Message_ID_LOGIN = 1,
  Message_ID_ROOMSTATE = 2,
  Message_ID_CHARACTERSTATE = 103
};
bool Message_ID_IsValid(int value);
const Message_ID Message_ID_ID_MIN = Message_ID_UNKNOWN;
const Message_ID Message_ID_ID_MAX = Message_ID_CHARACTERSTATE;
const int Message_ID_ID_ARRAYSIZE = Message_ID_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ID_descriptor();
inline const ::std::string& Message_ID_Name(Message_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ID_descriptor(), value);
}
inline bool Message_ID_Parse(
    const ::std::string& name, Message_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ID>(
    Message_ID_descriptor(), name, value);
}
// ===================================================================

class Vec2 : public ::google::protobuf::Message {
 public:
  Vec2();
  virtual ~Vec2();

  Vec2(const Vec2& from);

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec2& default_instance();

  void Swap(Vec2* other);

  // implements Message ----------------------------------------------

  inline Vec2* New() const { return New(NULL); }

  Vec2* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vec2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:Tank.Vec2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Vec2* default_instance_;
};
// -------------------------------------------------------------------

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  inline Vec3* New() const { return New(NULL); }

  Vec3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vec3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Tank.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Vec4 : public ::google::protobuf::Message {
 public:
  Vec4();
  virtual ~Vec4();

  Vec4(const Vec4& from);

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec4& default_instance();

  void Swap(Vec4* other);

  // implements Message ----------------------------------------------

  inline Vec4* New() const { return New(NULL); }

  Vec4* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vec4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:Tank.Vec4)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Vec4* default_instance_;
};
// -------------------------------------------------------------------

class MessageHeader : public ::google::protobuf::Message {
 public:
  MessageHeader();
  virtual ~MessageHeader();

  MessageHeader(const MessageHeader& from);

  inline MessageHeader& operator=(const MessageHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageHeader& default_instance();

  void Swap(MessageHeader* other);

  // implements Message ----------------------------------------------

  inline MessageHeader* New() const { return New(NULL); }

  MessageHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageHeader& from);
  void MergeFrom(const MessageHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 messageID = 1;
  bool has_messageid() const;
  void clear_messageid();
  static const int kMessageIDFieldNumber = 1;
  ::google::protobuf::uint32 messageid() const;
  void set_messageid(::google::protobuf::uint32 value);

  // required uint32 channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional .Tank.Login login = 105;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 105;
  const ::Tank::Login& login() const;
  ::Tank::Login* mutable_login();
  ::Tank::Login* release_login();
  void set_allocated_login(::Tank::Login* login);

  // optional .Tank.RoomState roomstate = 106;
  bool has_roomstate() const;
  void clear_roomstate();
  static const int kRoomstateFieldNumber = 106;
  const ::Tank::RoomState& roomstate() const;
  ::Tank::RoomState* mutable_roomstate();
  ::Tank::RoomState* release_roomstate();
  void set_allocated_roomstate(::Tank::RoomState* roomstate);

  // @@protoc_insertion_point(class_scope:Tank.MessageHeader)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_roomstate();
  inline void clear_has_roomstate();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 messageid_;
  ::google::protobuf::uint32 channel_;
  ::Tank::Login* login_;
  ::Tank::RoomState* roomstate_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static MessageHeader* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  inline Login* New() const { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ClientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  ::google::protobuf::uint32 clientid() const;
  void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Tank.Login)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 clientid_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class RoomState : public ::google::protobuf::Message {
 public:
  RoomState();
  virtual ~RoomState();

  RoomState(const RoomState& from);

  inline RoomState& operator=(const RoomState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomState& default_instance();

  void Swap(RoomState* other);

  // implements Message ----------------------------------------------

  inline RoomState* New() const { return New(NULL); }

  RoomState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomState& from);
  void MergeFrom(const RoomState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  ::google::protobuf::uint32 host() const;
  void set_host(::google::protobuf::uint32 value);

  // repeated uint32 clients = 2;
  int clients_size() const;
  void clear_clients();
  static const int kClientsFieldNumber = 2;
  ::google::protobuf::uint32 clients(int index) const;
  void set_clients(int index, ::google::protobuf::uint32 value);
  void add_clients(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      clients() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_clients();

  // @@protoc_insertion_point(class_scope:Tank.RoomState)
 private:
  inline void set_has_host();
  inline void clear_has_host();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > clients_;
  ::google::protobuf::uint32 host_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static RoomState* default_instance_;
};
// -------------------------------------------------------------------

class Message_CharacterState : public ::google::protobuf::Message {
 public:
  Message_CharacterState();
  virtual ~Message_CharacterState();

  Message_CharacterState(const Message_CharacterState& from);

  inline Message_CharacterState& operator=(const Message_CharacterState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_CharacterState& default_instance();

  void Swap(Message_CharacterState* other);

  // implements Message ----------------------------------------------

  inline Message_CharacterState* New() const { return New(NULL); }

  Message_CharacterState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_CharacterState& from);
  void MergeFrom(const Message_CharacterState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message_CharacterState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_CharacterState_ActionID ActionID;
  static const ActionID NONE = Message_CharacterState_ActionID_NONE;
  static const ActionID MOVEACTION = Message_CharacterState_ActionID_MOVEACTION;
  static const ActionID ROTATIONACTION = Message_CharacterState_ActionID_ROTATIONACTION;
  static const ActionID TURRETROTATIONACTION = Message_CharacterState_ActionID_TURRETROTATIONACTION;
  static const ActionID FIREACTION = Message_CharacterState_ActionID_FIREACTION;
  static inline bool ActionID_IsValid(int value) {
    return Message_CharacterState_ActionID_IsValid(value);
  }
  static const ActionID ActionID_MIN =
    Message_CharacterState_ActionID_ActionID_MIN;
  static const ActionID ActionID_MAX =
    Message_CharacterState_ActionID_ActionID_MAX;
  static const int ActionID_ARRAYSIZE =
    Message_CharacterState_ActionID_ActionID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionID_descriptor() {
    return Message_CharacterState_ActionID_descriptor();
  }
  static inline const ::std::string& ActionID_Name(ActionID value) {
    return Message_CharacterState_ActionID_Name(value);
  }
  static inline bool ActionID_Parse(const ::std::string& name,
      ActionID* value) {
    return Message_CharacterState_ActionID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 charID = 1;
  bool has_charid() const;
  void clear_charid();
  static const int kCharIDFieldNumber = 1;
  ::google::protobuf::uint32 charid() const;
  void set_charid(::google::protobuf::uint32 value);

  // required float time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  float time() const;
  void set_time(float value);

  // required .Tank.Message.CharacterState.ActionID action = 3;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 3;
  ::Tank::Message_CharacterState_ActionID action() const;
  void set_action(::Tank::Message_CharacterState_ActionID value);

  // required .Tank.Vec3 position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  const ::Tank::Vec3& position() const;
  ::Tank::Vec3* mutable_position();
  ::Tank::Vec3* release_position();
  void set_allocated_position(::Tank::Vec3* position);

  // optional .Tank.Vec3 direction = 5;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 5;
  const ::Tank::Vec3& direction() const;
  ::Tank::Vec3* mutable_direction();
  ::Tank::Vec3* release_direction();
  void set_allocated_direction(::Tank::Vec3* direction);

  // optional .Tank.Vec4 rotate = 6;
  bool has_rotate() const;
  void clear_rotate();
  static const int kRotateFieldNumber = 6;
  const ::Tank::Vec4& rotate() const;
  ::Tank::Vec4* mutable_rotate();
  ::Tank::Vec4* release_rotate();
  void set_allocated_rotate(::Tank::Vec4* rotate);

  // optional float curspeed = 7;
  bool has_curspeed() const;
  void clear_curspeed();
  static const int kCurspeedFieldNumber = 7;
  float curspeed() const;
  void set_curspeed(float value);

  // optional float speed = 8;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 8;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:Tank.Message.CharacterState)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_rotate();
  inline void clear_has_rotate();
  inline void set_has_curspeed();
  inline void clear_has_curspeed();
  inline void set_has_speed();
  inline void clear_has_speed();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 charid_;
  float time_;
  ::Tank::Vec3* position_;
  ::Tank::Vec3* direction_;
  int action_;
  float curspeed_;
  ::Tank::Vec4* rotate_;
  float speed_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Message_CharacterState* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_CharacterState CharacterState;

  typedef Message_ID ID;
  static const ID UNKNOWN = Message_ID_UNKNOWN;
  static const ID LOGIN = Message_ID_LOGIN;
  static const ID ROOMSTATE = Message_ID_ROOMSTATE;
  static const ID CHARACTERSTATE = Message_ID_CHARACTERSTATE;
  static inline bool ID_IsValid(int value) {
    return Message_ID_IsValid(value);
  }
  static const ID ID_MIN =
    Message_ID_ID_MIN;
  static const ID ID_MAX =
    Message_ID_ID_MAX;
  static const int ID_ARRAYSIZE =
    Message_ID_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ID_descriptor() {
    return Message_ID_descriptor();
  }
  static inline const ::std::string& ID_Name(ID value) {
    return Message_ID_Name(value);
  }
  static inline bool ID_Parse(const ::std::string& name,
      ID* value) {
    return Message_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Tank.Message.CharacterState characterstate = 104;
  bool has_characterstate() const;
  void clear_characterstate();
  static const int kCharacterstateFieldNumber = 104;
  const ::Tank::Message_CharacterState& characterstate() const;
  ::Tank::Message_CharacterState* mutable_characterstate();
  ::Tank::Message_CharacterState* release_characterstate();
  void set_allocated_characterstate(::Tank::Message_CharacterState* characterstate);

  // @@protoc_insertion_point(class_scope:Tank.Message)
 private:
  inline void set_has_characterstate();
  inline void clear_has_characterstate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Tank::Message_CharacterState* characterstate_;
  friend void  protobuf_AddDesc_Tank_2eproto();
  friend void protobuf_AssignDesc_Tank_2eproto();
  friend void protobuf_ShutdownFile_Tank_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vec2

// required float x = 1;
inline bool Vec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec2::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec2.x)
  return x_;
}
inline void Vec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec2.x)
}

// required float y = 2;
inline bool Vec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec2::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec2.y)
  return y_;
}
inline void Vec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// required float x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.x)
}

// required float y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.y)
}

// required float z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.z)
}

// -------------------------------------------------------------------

// Vec4

// required float x = 1;
inline bool Vec4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec4::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.x)
  return x_;
}
inline void Vec4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.x)
}

// required float y = 2;
inline bool Vec4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec4::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.y)
  return y_;
}
inline void Vec4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.y)
}

// required float z = 3;
inline bool Vec4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec4::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.z)
  return z_;
}
inline void Vec4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.z)
}

// required float w = 4;
inline bool Vec4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vec4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vec4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vec4::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.w)
  return w_;
}
inline void Vec4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.w)
}

// -------------------------------------------------------------------

// MessageHeader

// required uint32 messageID = 1;
inline bool MessageHeader::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageHeader::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageHeader::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageHeader::clear_messageid() {
  messageid_ = 0u;
  clear_has_messageid();
}
inline ::google::protobuf::uint32 MessageHeader::messageid() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.messageID)
  return messageid_;
}
inline void MessageHeader::set_messageid(::google::protobuf::uint32 value) {
  set_has_messageid();
  messageid_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.messageID)
}

// required uint32 channel = 2;
inline bool MessageHeader::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageHeader::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageHeader::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageHeader::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 MessageHeader::channel() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.channel)
  return channel_;
}
inline void MessageHeader::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.channel)
}

// required uint32 index = 3;
inline bool MessageHeader::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageHeader::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageHeader::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageHeader::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 MessageHeader::index() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.index)
  return index_;
}
inline void MessageHeader::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.index)
}

// optional .Tank.Login login = 105;
inline bool MessageHeader::has_login() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageHeader::set_has_login() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageHeader::clear_has_login() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageHeader::clear_login() {
  if (login_ != NULL) login_->::Tank::Login::Clear();
  clear_has_login();
}
inline const ::Tank::Login& MessageHeader::login() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.login)
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::Tank::Login* MessageHeader::mutable_login() {
  set_has_login();
  if (login_ == NULL) {
    login_ = new ::Tank::Login;
  }
  // @@protoc_insertion_point(field_mutable:Tank.MessageHeader.login)
  return login_;
}
inline ::Tank::Login* MessageHeader::release_login() {
  clear_has_login();
  ::Tank::Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void MessageHeader::set_allocated_login(::Tank::Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.MessageHeader.login)
}

// optional .Tank.RoomState roomstate = 106;
inline bool MessageHeader::has_roomstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageHeader::set_has_roomstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageHeader::clear_has_roomstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageHeader::clear_roomstate() {
  if (roomstate_ != NULL) roomstate_->::Tank::RoomState::Clear();
  clear_has_roomstate();
}
inline const ::Tank::RoomState& MessageHeader::roomstate() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.roomstate)
  return roomstate_ != NULL ? *roomstate_ : *default_instance_->roomstate_;
}
inline ::Tank::RoomState* MessageHeader::mutable_roomstate() {
  set_has_roomstate();
  if (roomstate_ == NULL) {
    roomstate_ = new ::Tank::RoomState;
  }
  // @@protoc_insertion_point(field_mutable:Tank.MessageHeader.roomstate)
  return roomstate_;
}
inline ::Tank::RoomState* MessageHeader::release_roomstate() {
  clear_has_roomstate();
  ::Tank::RoomState* temp = roomstate_;
  roomstate_ = NULL;
  return temp;
}
inline void MessageHeader::set_allocated_roomstate(::Tank::RoomState* roomstate) {
  delete roomstate_;
  roomstate_ = roomstate;
  if (roomstate) {
    set_has_roomstate();
  } else {
    clear_has_roomstate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.MessageHeader.roomstate)
}

// -------------------------------------------------------------------

// Login

// required uint32 ClientId = 1;
inline bool Login::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 Login::clientid() const {
  // @@protoc_insertion_point(field_get:Tank.Login.ClientId)
  return clientid_;
}
inline void Login::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:Tank.Login.ClientId)
}

// -------------------------------------------------------------------

// RoomState

// required uint32 host = 1;
inline bool RoomState::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomState::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomState::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomState::clear_host() {
  host_ = 0u;
  clear_has_host();
}
inline ::google::protobuf::uint32 RoomState::host() const {
  // @@protoc_insertion_point(field_get:Tank.RoomState.host)
  return host_;
}
inline void RoomState::set_host(::google::protobuf::uint32 value) {
  set_has_host();
  host_ = value;
  // @@protoc_insertion_point(field_set:Tank.RoomState.host)
}

// repeated uint32 clients = 2;
inline int RoomState::clients_size() const {
  return clients_.size();
}
inline void RoomState::clear_clients() {
  clients_.Clear();
}
inline ::google::protobuf::uint32 RoomState::clients(int index) const {
  // @@protoc_insertion_point(field_get:Tank.RoomState.clients)
  return clients_.Get(index);
}
inline void RoomState::set_clients(int index, ::google::protobuf::uint32 value) {
  clients_.Set(index, value);
  // @@protoc_insertion_point(field_set:Tank.RoomState.clients)
}
inline void RoomState::add_clients(::google::protobuf::uint32 value) {
  clients_.Add(value);
  // @@protoc_insertion_point(field_add:Tank.RoomState.clients)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RoomState::clients() const {
  // @@protoc_insertion_point(field_list:Tank.RoomState.clients)
  return clients_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RoomState::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Tank.RoomState.clients)
  return &clients_;
}

// -------------------------------------------------------------------

// Message_CharacterState

// required uint32 charID = 1;
inline bool Message_CharacterState::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_CharacterState::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_CharacterState::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_CharacterState::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 Message_CharacterState::charid() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.charID)
  return charid_;
}
inline void Message_CharacterState::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.charID)
}

// required float time = 2;
inline bool Message_CharacterState::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_CharacterState::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_CharacterState::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_CharacterState::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float Message_CharacterState::time() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.time)
  return time_;
}
inline void Message_CharacterState::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.time)
}

// required .Tank.Message.CharacterState.ActionID action = 3;
inline bool Message_CharacterState::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_CharacterState::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_CharacterState::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_CharacterState::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::Tank::Message_CharacterState_ActionID Message_CharacterState::action() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.action)
  return static_cast< ::Tank::Message_CharacterState_ActionID >(action_);
}
inline void Message_CharacterState::set_action(::Tank::Message_CharacterState_ActionID value) {
  assert(::Tank::Message_CharacterState_ActionID_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.action)
}

// required .Tank.Vec3 position = 4;
inline bool Message_CharacterState::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_CharacterState::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_CharacterState::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_CharacterState::clear_position() {
  if (position_ != NULL) position_->::Tank::Vec3::Clear();
  clear_has_position();
}
inline const ::Tank::Vec3& Message_CharacterState::position() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Tank::Vec3* Message_CharacterState::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Tank::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.position)
  return position_;
}
inline ::Tank::Vec3* Message_CharacterState::release_position() {
  clear_has_position();
  ::Tank::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Message_CharacterState::set_allocated_position(::Tank::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.position)
}

// optional .Tank.Vec3 direction = 5;
inline bool Message_CharacterState::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_CharacterState::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_CharacterState::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_CharacterState::clear_direction() {
  if (direction_ != NULL) direction_->::Tank::Vec3::Clear();
  clear_has_direction();
}
inline const ::Tank::Vec3& Message_CharacterState::direction() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Tank::Vec3* Message_CharacterState::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::Tank::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.direction)
  return direction_;
}
inline ::Tank::Vec3* Message_CharacterState::release_direction() {
  clear_has_direction();
  ::Tank::Vec3* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void Message_CharacterState::set_allocated_direction(::Tank::Vec3* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.direction)
}

// optional .Tank.Vec4 rotate = 6;
inline bool Message_CharacterState::has_rotate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_CharacterState::set_has_rotate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_CharacterState::clear_has_rotate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_CharacterState::clear_rotate() {
  if (rotate_ != NULL) rotate_->::Tank::Vec4::Clear();
  clear_has_rotate();
}
inline const ::Tank::Vec4& Message_CharacterState::rotate() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.rotate)
  return rotate_ != NULL ? *rotate_ : *default_instance_->rotate_;
}
inline ::Tank::Vec4* Message_CharacterState::mutable_rotate() {
  set_has_rotate();
  if (rotate_ == NULL) {
    rotate_ = new ::Tank::Vec4;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.rotate)
  return rotate_;
}
inline ::Tank::Vec4* Message_CharacterState::release_rotate() {
  clear_has_rotate();
  ::Tank::Vec4* temp = rotate_;
  rotate_ = NULL;
  return temp;
}
inline void Message_CharacterState::set_allocated_rotate(::Tank::Vec4* rotate) {
  delete rotate_;
  rotate_ = rotate;
  if (rotate) {
    set_has_rotate();
  } else {
    clear_has_rotate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.rotate)
}

// optional float curspeed = 7;
inline bool Message_CharacterState::has_curspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_CharacterState::set_has_curspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_CharacterState::clear_has_curspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_CharacterState::clear_curspeed() {
  curspeed_ = 0;
  clear_has_curspeed();
}
inline float Message_CharacterState::curspeed() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.curspeed)
  return curspeed_;
}
inline void Message_CharacterState::set_curspeed(float value) {
  set_has_curspeed();
  curspeed_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.curspeed)
}

// optional float speed = 8;
inline bool Message_CharacterState::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_CharacterState::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_CharacterState::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_CharacterState::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float Message_CharacterState::speed() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.speed)
  return speed_;
}
inline void Message_CharacterState::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.speed)
}

// -------------------------------------------------------------------

// Message

// optional .Tank.Message.CharacterState characterstate = 104;
inline bool Message::has_characterstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_characterstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_characterstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_characterstate() {
  if (characterstate_ != NULL) characterstate_->::Tank::Message_CharacterState::Clear();
  clear_has_characterstate();
}
inline const ::Tank::Message_CharacterState& Message::characterstate() const {
  // @@protoc_insertion_point(field_get:Tank.Message.characterstate)
  return characterstate_ != NULL ? *characterstate_ : *default_instance_->characterstate_;
}
inline ::Tank::Message_CharacterState* Message::mutable_characterstate() {
  set_has_characterstate();
  if (characterstate_ == NULL) {
    characterstate_ = new ::Tank::Message_CharacterState;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.characterstate)
  return characterstate_;
}
inline ::Tank::Message_CharacterState* Message::release_characterstate() {
  clear_has_characterstate();
  ::Tank::Message_CharacterState* temp = characterstate_;
  characterstate_ = NULL;
  return temp;
}
inline void Message::set_allocated_characterstate(::Tank::Message_CharacterState* characterstate) {
  delete characterstate_;
  characterstate_ = characterstate;
  if (characterstate) {
    set_has_characterstate();
  } else {
    clear_has_characterstate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.characterstate)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Tank

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Tank::Message_CharacterState_ActionID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Tank::Message_CharacterState_ActionID>() {
  return ::Tank::Message_CharacterState_ActionID_descriptor();
}
template <> struct is_proto_enum< ::Tank::Message_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Tank::Message_ID>() {
  return ::Tank::Message_ID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Tank_2eproto__INCLUDED
