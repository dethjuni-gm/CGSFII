// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Tank.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Tank.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Tank {

namespace {

const ::google::protobuf::Descriptor* Vec2_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vec2_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vec3_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vec3_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vec4_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vec4_reflection_ = NULL;
const ::google::protobuf::Descriptor* MessageHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MessageHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* Login_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Login_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoomState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoomState_reflection_ = NULL;
const ::google::protobuf::Descriptor* Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* Message_CharacterState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_CharacterState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Message_CharacterState_ActionID_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Message_ID_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Tank_2eproto() {
  protobuf_AddDesc_Tank_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Tank.proto");
  GOOGLE_CHECK(file != NULL);
  Vec2_descriptor_ = file->message_type(0);
  static const int Vec2_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec2, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec2, y_),
  };
  Vec2_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Vec2_descriptor_,
      Vec2::default_instance_,
      Vec2_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec2, _has_bits_[0]),
      -1,
      -1,
      sizeof(Vec2),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec2, _internal_metadata_),
      -1);
  Vec3_descriptor_ = file->message_type(1);
  static const int Vec3_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, z_),
  };
  Vec3_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Vec3_descriptor_,
      Vec3::default_instance_,
      Vec3_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, _has_bits_[0]),
      -1,
      -1,
      sizeof(Vec3),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, _internal_metadata_),
      -1);
  Vec4_descriptor_ = file->message_type(2);
  static const int Vec4_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, w_),
  };
  Vec4_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Vec4_descriptor_,
      Vec4::default_instance_,
      Vec4_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, _has_bits_[0]),
      -1,
      -1,
      sizeof(Vec4),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec4, _internal_metadata_),
      -1);
  MessageHeader_descriptor_ = file->message_type(3);
  static const int MessageHeader_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, messageid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, login_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, roomstate_),
  };
  MessageHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MessageHeader_descriptor_,
      MessageHeader::default_instance_,
      MessageHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(MessageHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageHeader, _internal_metadata_),
      -1);
  Login_descriptor_ = file->message_type(4);
  static const int Login_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, clientid_),
  };
  Login_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Login_descriptor_,
      Login::default_instance_,
      Login_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, _has_bits_[0]),
      -1,
      -1,
      sizeof(Login),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, _internal_metadata_),
      -1);
  RoomState_descriptor_ = file->message_type(5);
  static const int RoomState_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomState, host_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomState, clients_),
  };
  RoomState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RoomState_descriptor_,
      RoomState::default_instance_,
      RoomState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomState, _has_bits_[0]),
      -1,
      -1,
      sizeof(RoomState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomState, _internal_metadata_),
      -1);
  Message_descriptor_ = file->message_type(6);
  static const int Message_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, characterstate_),
  };
  Message_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Message_descriptor_,
      Message::default_instance_,
      Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _has_bits_[0]),
      -1,
      -1,
      sizeof(Message),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _internal_metadata_),
      -1);
  Message_CharacterState_descriptor_ = Message_descriptor_->nested_type(0);
  static const int Message_CharacterState_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, rotate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, curspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, speed_),
  };
  Message_CharacterState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Message_CharacterState_descriptor_,
      Message_CharacterState::default_instance_,
      Message_CharacterState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, _has_bits_[0]),
      -1,
      -1,
      sizeof(Message_CharacterState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message_CharacterState, _internal_metadata_),
      -1);
  Message_CharacterState_ActionID_descriptor_ = Message_CharacterState_descriptor_->enum_type(0);
  Message_ID_descriptor_ = Message_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Tank_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Vec2_descriptor_, &Vec2::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Vec3_descriptor_, &Vec3::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Vec4_descriptor_, &Vec4::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MessageHeader_descriptor_, &MessageHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Login_descriptor_, &Login::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RoomState_descriptor_, &RoomState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Message_descriptor_, &Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Message_CharacterState_descriptor_, &Message_CharacterState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Tank_2eproto() {
  delete Vec2::default_instance_;
  delete Vec2_reflection_;
  delete Vec3::default_instance_;
  delete Vec3_reflection_;
  delete Vec4::default_instance_;
  delete Vec4_reflection_;
  delete MessageHeader::default_instance_;
  delete MessageHeader_reflection_;
  delete Login::default_instance_;
  delete Login_reflection_;
  delete RoomState::default_instance_;
  delete RoomState_reflection_;
  delete Message::default_instance_;
  delete Message_reflection_;
  delete Message_CharacterState::default_instance_;
  delete Message_CharacterState_reflection_;
}

void protobuf_AddDesc_Tank_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nTank.proto\022\004Tank\"\034\n\004Vec2\022\t\n\001x\030\001 \002(\002\022\t\n"
    "\001y\030\002 \002(\002\"\'\n\004Vec3\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t"
    "\n\001z\030\003 \002(\002\"2\n\004Vec4\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022"
    "\t\n\001z\030\003 \002(\002\022\t\n\001w\030\004 \002(\002\"\202\001\n\rMessageHeader\022"
    "\021\n\tmessageID\030\001 \002(\r\022\017\n\007channel\030\002 \002(\r\022\r\n\005i"
    "ndex\030\003 \002(\r\022\032\n\005login\030i \001(\0132\013.Tank.Login\022\""
    "\n\troomstate\030j \001(\0132\017.Tank.RoomState\"\031\n\005Lo"
    "gin\022\020\n\010ClientId\030\001 \002(\r\"*\n\tRoomState\022\014\n\004ho"
    "st\030\001 \002(\r\022\017\n\007clients\030\002 \003(\r\"\306\003\n\007Message\0224\n"
    "\016characterstate\030h \001(\0132\034.Tank.Message.Cha"
    "racterState\032\303\002\n\016CharacterState\022\016\n\006charID"
    "\030\001 \002(\r\022\014\n\004time\030\002 \002(\002\0225\n\006action\030\003 \002(\0162%.T"
    "ank.Message.CharacterState.ActionID\022\034\n\010p"
    "osition\030\004 \002(\0132\n.Tank.Vec3\022\035\n\tdirection\030\005"
    " \001(\0132\n.Tank.Vec3\022\032\n\006rotate\030\006 \001(\0132\n.Tank."
    "Vec4\022\020\n\010curspeed\030\007 \001(\002\022\r\n\005speed\030\010 \001(\002\"b\n"
    "\010ActionID\022\010\n\004NONE\020\000\022\016\n\nMOVEACTION\020\001\022\022\n\016R"
    "OTATIONACTION\020\002\022\030\n\024TURRETROTATIONACTION\020"
    "\003\022\016\n\nFIREACTION\020\004\"\?\n\002ID\022\013\n\007UNKNOWN\020\000\022\t\n\005"
    "LOGIN\020\001\022\r\n\tROOMSTATE\020\002\022\022\n\016CHARACTERSTATE"
    "\020g", 802);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Tank.proto", &protobuf_RegisterTypes);
  Vec2::default_instance_ = new Vec2();
  Vec3::default_instance_ = new Vec3();
  Vec4::default_instance_ = new Vec4();
  MessageHeader::default_instance_ = new MessageHeader();
  Login::default_instance_ = new Login();
  RoomState::default_instance_ = new RoomState();
  Message::default_instance_ = new Message();
  Message_CharacterState::default_instance_ = new Message_CharacterState();
  Vec2::default_instance_->InitAsDefaultInstance();
  Vec3::default_instance_->InitAsDefaultInstance();
  Vec4::default_instance_->InitAsDefaultInstance();
  MessageHeader::default_instance_->InitAsDefaultInstance();
  Login::default_instance_->InitAsDefaultInstance();
  RoomState::default_instance_->InitAsDefaultInstance();
  Message::default_instance_->InitAsDefaultInstance();
  Message_CharacterState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Tank_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Tank_2eproto {
  StaticDescriptorInitializer_Tank_2eproto() {
    protobuf_AddDesc_Tank_2eproto();
  }
} static_descriptor_initializer_Tank_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec2::kXFieldNumber;
const int Vec2::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec2::Vec2()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Vec2)
}

void Vec2::InitAsDefaultInstance() {
}

Vec2::Vec2(const Vec2& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Vec2)
}

void Vec2::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vec2::~Vec2() {
  // @@protoc_insertion_point(destructor:Tank.Vec2)
  SharedDtor();
}

void Vec2::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vec2::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vec2::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vec2_descriptor_;
}

const Vec2& Vec2::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Vec2* Vec2::default_instance_ = NULL;

Vec2* Vec2::New(::google::protobuf::Arena* arena) const {
  Vec2* n = new Vec2;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Vec2::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Vec2*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, y_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Vec2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Vec2)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Vec2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Vec2)
  return false;
#undef DO_
}

void Vec2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Vec2)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Vec2)
}

::google::protobuf::uint8* Vec2::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Vec2)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Vec2)
  return target;
}

int Vec2::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
int Vec2::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vec2::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Vec2* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Vec2>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vec2::MergeFrom(const Vec2& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Vec2::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec2::CopyFrom(const Vec2& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec2::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Vec2::Swap(Vec2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec2::InternalSwap(Vec2* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Vec2::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vec2_descriptor_;
  metadata.reflection = Vec2_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Vec2

// required float x = 1;
bool Vec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Vec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Vec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Vec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Vec2::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec2.x)
  return x_;
}
 void Vec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec2.x)
}

// required float y = 2;
bool Vec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Vec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Vec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Vec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Vec2::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec2.y)
  return y_;
}
 void Vec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec2.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec3::kXFieldNumber;
const int Vec3::kYFieldNumber;
const int Vec3::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec3::Vec3()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Vec3)
}

void Vec3::InitAsDefaultInstance() {
}

Vec3::Vec3(const Vec3& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Vec3)
}

void Vec3::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vec3::~Vec3() {
  // @@protoc_insertion_point(destructor:Tank.Vec3)
  SharedDtor();
}

void Vec3::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vec3::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vec3::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vec3_descriptor_;
}

const Vec3& Vec3::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Vec3* Vec3::default_instance_ = NULL;

Vec3* Vec3::New(::google::protobuf::Arena* arena) const {
  Vec3* n = new Vec3;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Vec3::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Vec3*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Vec3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Vec3)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Vec3)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Vec3)
  return false;
#undef DO_
}

void Vec3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Vec3)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Vec3)
}

::google::protobuf::uint8* Vec3::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Vec3)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Vec3)
  return target;
}

int Vec3::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int Vec3::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vec3::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Vec3* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Vec3>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vec3::MergeFrom(const Vec3& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Vec3::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec3::CopyFrom(const Vec3& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec3::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Vec3::Swap(Vec3* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec3::InternalSwap(Vec3* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Vec3::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vec3_descriptor_;
  metadata.reflection = Vec3_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Vec3

// required float x = 1;
bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Vec3::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.x)
  return x_;
}
 void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.x)
}

// required float y = 2;
bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Vec3::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.y)
  return y_;
}
 void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.y)
}

// required float z = 3;
bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
 float Vec3::z() const {
  // @@protoc_insertion_point(field_get:Tank.Vec3.z)
  return z_;
}
 void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec3.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec4::kXFieldNumber;
const int Vec4::kYFieldNumber;
const int Vec4::kZFieldNumber;
const int Vec4::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec4::Vec4()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Vec4)
}

void Vec4::InitAsDefaultInstance() {
}

Vec4::Vec4(const Vec4& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Vec4)
}

void Vec4::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vec4::~Vec4() {
  // @@protoc_insertion_point(destructor:Tank.Vec4)
  SharedDtor();
}

void Vec4::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vec4::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vec4::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vec4_descriptor_;
}

const Vec4& Vec4::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Vec4* Vec4::default_instance_ = NULL;

Vec4* Vec4::New(::google::protobuf::Arena* arena) const {
  Vec4* n = new Vec4;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Vec4::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Vec4*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Vec4::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Vec4)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_w;
        break;
      }

      // required float w = 4;
      case 4: {
        if (tag == 37) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Vec4)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Vec4)
  return false;
#undef DO_
}

void Vec4::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Vec4)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  // required float w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Vec4)
}

::google::protobuf::uint8* Vec4::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Vec4)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  // required float w = 4;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Vec4)
  return target;
}

int Vec4::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  if (has_w()) {
    // required float w = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
int Vec4::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

    // required float w = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vec4::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Vec4* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Vec4>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vec4::MergeFrom(const Vec4& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Vec4::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec4::CopyFrom(const Vec4& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec4::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Vec4::Swap(Vec4* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec4::InternalSwap(Vec4* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Vec4::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vec4_descriptor_;
  metadata.reflection = Vec4_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Vec4

// required float x = 1;
bool Vec4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Vec4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Vec4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Vec4::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Vec4::x() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.x)
  return x_;
}
 void Vec4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.x)
}

// required float y = 2;
bool Vec4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Vec4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Vec4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Vec4::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Vec4::y() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.y)
  return y_;
}
 void Vec4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.y)
}

// required float z = 3;
bool Vec4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Vec4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Vec4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Vec4::clear_z() {
  z_ = 0;
  clear_has_z();
}
 float Vec4::z() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.z)
  return z_;
}
 void Vec4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.z)
}

// required float w = 4;
bool Vec4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Vec4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
void Vec4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void Vec4::clear_w() {
  w_ = 0;
  clear_has_w();
}
 float Vec4::w() const {
  // @@protoc_insertion_point(field_get:Tank.Vec4.w)
  return w_;
}
 void Vec4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Tank.Vec4.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageHeader::kMessageIDFieldNumber;
const int MessageHeader::kChannelFieldNumber;
const int MessageHeader::kIndexFieldNumber;
const int MessageHeader::kLoginFieldNumber;
const int MessageHeader::kRoomstateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageHeader::MessageHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.MessageHeader)
}

void MessageHeader::InitAsDefaultInstance() {
  login_ = const_cast< ::Tank::Login*>(&::Tank::Login::default_instance());
  roomstate_ = const_cast< ::Tank::RoomState*>(&::Tank::RoomState::default_instance());
}

MessageHeader::MessageHeader(const MessageHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.MessageHeader)
}

void MessageHeader::SharedCtor() {
  _cached_size_ = 0;
  messageid_ = 0u;
  channel_ = 0u;
  index_ = 0u;
  login_ = NULL;
  roomstate_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MessageHeader::~MessageHeader() {
  // @@protoc_insertion_point(destructor:Tank.MessageHeader)
  SharedDtor();
}

void MessageHeader::SharedDtor() {
  if (this != default_instance_) {
    delete login_;
    delete roomstate_;
  }
}

void MessageHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MessageHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageHeader_descriptor_;
}

const MessageHeader& MessageHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

MessageHeader* MessageHeader::default_instance_ = NULL;

MessageHeader* MessageHeader::New(::google::protobuf::Arena* arena) const {
  MessageHeader* n = new MessageHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MessageHeader::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MessageHeader*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(messageid_, channel_);
    index_ = 0u;
    if (has_login()) {
      if (login_ != NULL) login_->::Tank::Login::Clear();
    }
    if (has_roomstate()) {
      if (roomstate_ != NULL) roomstate_->::Tank::RoomState::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MessageHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.MessageHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 messageID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &messageid_)));
          set_has_messageid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_channel;
        break;
      }

      // required uint32 channel = 2;
      case 2: {
        if (tag == 16) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(842)) goto parse_login;
        break;
      }

      // optional .Tank.Login login = 105;
      case 105: {
        if (tag == 842) {
         parse_login:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_login()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(850)) goto parse_roomstate;
        break;
      }

      // optional .Tank.RoomState roomstate = 106;
      case 106: {
        if (tag == 850) {
         parse_roomstate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roomstate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.MessageHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.MessageHeader)
  return false;
#undef DO_
}

void MessageHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.MessageHeader)
  // required uint32 messageID = 1;
  if (has_messageid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->messageid(), output);
  }

  // required uint32 channel = 2;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->channel(), output);
  }

  // required uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // optional .Tank.Login login = 105;
  if (has_login()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      105, *this->login_, output);
  }

  // optional .Tank.RoomState roomstate = 106;
  if (has_roomstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      106, *this->roomstate_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.MessageHeader)
}

::google::protobuf::uint8* MessageHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.MessageHeader)
  // required uint32 messageID = 1;
  if (has_messageid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->messageid(), target);
  }

  // required uint32 channel = 2;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->channel(), target);
  }

  // required uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // optional .Tank.Login login = 105;
  if (has_login()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        105, *this->login_, target);
  }

  // optional .Tank.RoomState roomstate = 106;
  if (has_roomstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        106, *this->roomstate_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.MessageHeader)
  return target;
}

int MessageHeader::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_messageid()) {
    // required uint32 messageID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->messageid());
  }

  if (has_channel()) {
    // required uint32 channel = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->channel());
  }

  if (has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  return total_size;
}
int MessageHeader::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 messageID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->messageid());

    // required uint32 channel = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->channel());

    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 24u) {
    // optional .Tank.Login login = 105;
    if (has_login()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->login_);
    }

    // optional .Tank.RoomState roomstate = 106;
    if (has_roomstate()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->roomstate_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MessageHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MessageHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MessageHeader::MergeFrom(const MessageHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_messageid()) {
      set_messageid(from.messageid());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_login()) {
      mutable_login()->::Tank::Login::MergeFrom(from.login());
    }
    if (from.has_roomstate()) {
      mutable_roomstate()->::Tank::RoomState::MergeFrom(from.roomstate());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MessageHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageHeader::CopyFrom(const MessageHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_login()) {
    if (!this->login_->IsInitialized()) return false;
  }
  if (has_roomstate()) {
    if (!this->roomstate_->IsInitialized()) return false;
  }
  return true;
}

void MessageHeader::Swap(MessageHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageHeader::InternalSwap(MessageHeader* other) {
  std::swap(messageid_, other->messageid_);
  std::swap(channel_, other->channel_);
  std::swap(index_, other->index_);
  std::swap(login_, other->login_);
  std::swap(roomstate_, other->roomstate_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MessageHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MessageHeader_descriptor_;
  metadata.reflection = MessageHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MessageHeader

// required uint32 messageID = 1;
bool MessageHeader::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MessageHeader::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
void MessageHeader::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
void MessageHeader::clear_messageid() {
  messageid_ = 0u;
  clear_has_messageid();
}
 ::google::protobuf::uint32 MessageHeader::messageid() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.messageID)
  return messageid_;
}
 void MessageHeader::set_messageid(::google::protobuf::uint32 value) {
  set_has_messageid();
  messageid_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.messageID)
}

// required uint32 channel = 2;
bool MessageHeader::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MessageHeader::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
void MessageHeader::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
void MessageHeader::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
 ::google::protobuf::uint32 MessageHeader::channel() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.channel)
  return channel_;
}
 void MessageHeader::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.channel)
}

// required uint32 index = 3;
bool MessageHeader::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MessageHeader::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void MessageHeader::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void MessageHeader::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 MessageHeader::index() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.index)
  return index_;
}
 void MessageHeader::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Tank.MessageHeader.index)
}

// optional .Tank.Login login = 105;
bool MessageHeader::has_login() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void MessageHeader::set_has_login() {
  _has_bits_[0] |= 0x00000008u;
}
void MessageHeader::clear_has_login() {
  _has_bits_[0] &= ~0x00000008u;
}
void MessageHeader::clear_login() {
  if (login_ != NULL) login_->::Tank::Login::Clear();
  clear_has_login();
}
const ::Tank::Login& MessageHeader::login() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.login)
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
::Tank::Login* MessageHeader::mutable_login() {
  set_has_login();
  if (login_ == NULL) {
    login_ = new ::Tank::Login;
  }
  // @@protoc_insertion_point(field_mutable:Tank.MessageHeader.login)
  return login_;
}
::Tank::Login* MessageHeader::release_login() {
  clear_has_login();
  ::Tank::Login* temp = login_;
  login_ = NULL;
  return temp;
}
void MessageHeader::set_allocated_login(::Tank::Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.MessageHeader.login)
}

// optional .Tank.RoomState roomstate = 106;
bool MessageHeader::has_roomstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void MessageHeader::set_has_roomstate() {
  _has_bits_[0] |= 0x00000010u;
}
void MessageHeader::clear_has_roomstate() {
  _has_bits_[0] &= ~0x00000010u;
}
void MessageHeader::clear_roomstate() {
  if (roomstate_ != NULL) roomstate_->::Tank::RoomState::Clear();
  clear_has_roomstate();
}
const ::Tank::RoomState& MessageHeader::roomstate() const {
  // @@protoc_insertion_point(field_get:Tank.MessageHeader.roomstate)
  return roomstate_ != NULL ? *roomstate_ : *default_instance_->roomstate_;
}
::Tank::RoomState* MessageHeader::mutable_roomstate() {
  set_has_roomstate();
  if (roomstate_ == NULL) {
    roomstate_ = new ::Tank::RoomState;
  }
  // @@protoc_insertion_point(field_mutable:Tank.MessageHeader.roomstate)
  return roomstate_;
}
::Tank::RoomState* MessageHeader::release_roomstate() {
  clear_has_roomstate();
  ::Tank::RoomState* temp = roomstate_;
  roomstate_ = NULL;
  return temp;
}
void MessageHeader::set_allocated_roomstate(::Tank::RoomState* roomstate) {
  delete roomstate_;
  roomstate_ = roomstate;
  if (roomstate) {
    set_has_roomstate();
  } else {
    clear_has_roomstate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.MessageHeader.roomstate)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Login::kClientIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Login::Login()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Login)
}

void Login::InitAsDefaultInstance() {
}

Login::Login(const Login& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Login)
}

void Login::SharedCtor() {
  _cached_size_ = 0;
  clientid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Login::~Login() {
  // @@protoc_insertion_point(destructor:Tank.Login)
  SharedDtor();
}

void Login::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Login::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Login::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Login_descriptor_;
}

const Login& Login::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Login* Login::default_instance_ = NULL;

Login* Login::New(::google::protobuf::Arena* arena) const {
  Login* n = new Login;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Login::Clear() {
  clientid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Login::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Login)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ClientId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &clientid_)));
          set_has_clientid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Login)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Login)
  return false;
#undef DO_
}

void Login::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Login)
  // required uint32 ClientId = 1;
  if (has_clientid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->clientid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Login)
}

::google::protobuf::uint8* Login::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Login)
  // required uint32 ClientId = 1;
  if (has_clientid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->clientid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Login)
  return target;
}

int Login::ByteSize() const {
  int total_size = 0;

  // required uint32 ClientId = 1;
  if (has_clientid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->clientid());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Login::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Login* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Login>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Login::MergeFrom(const Login& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clientid()) {
      set_clientid(from.clientid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Login::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Login::CopyFrom(const Login& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Login::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Login::Swap(Login* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Login::InternalSwap(Login* other) {
  std::swap(clientid_, other->clientid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Login::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Login_descriptor_;
  metadata.reflection = Login_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Login

// required uint32 ClientId = 1;
bool Login::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Login::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
void Login::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
void Login::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
 ::google::protobuf::uint32 Login::clientid() const {
  // @@protoc_insertion_point(field_get:Tank.Login.ClientId)
  return clientid_;
}
 void Login::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:Tank.Login.ClientId)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoomState::kHostFieldNumber;
const int RoomState::kClientsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoomState::RoomState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.RoomState)
}

void RoomState::InitAsDefaultInstance() {
}

RoomState::RoomState(const RoomState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.RoomState)
}

void RoomState::SharedCtor() {
  _cached_size_ = 0;
  host_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoomState::~RoomState() {
  // @@protoc_insertion_point(destructor:Tank.RoomState)
  SharedDtor();
}

void RoomState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RoomState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoomState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoomState_descriptor_;
}

const RoomState& RoomState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

RoomState* RoomState::default_instance_ = NULL;

RoomState* RoomState::New(::google::protobuf::Arena* arena) const {
  RoomState* n = new RoomState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoomState::Clear() {
  host_ = 0u;
  clients_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RoomState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.RoomState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_)));
          set_has_host();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_clients;
        break;
      }

      // repeated uint32 clients = 2;
      case 2: {
        if (tag == 16) {
         parse_clients:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_clients())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_clients())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_clients;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.RoomState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.RoomState)
  return false;
#undef DO_
}

void RoomState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.RoomState)
  // required uint32 host = 1;
  if (has_host()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host(), output);
  }

  // repeated uint32 clients = 2;
  for (int i = 0; i < this->clients_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->clients(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.RoomState)
}

::google::protobuf::uint8* RoomState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.RoomState)
  // required uint32 host = 1;
  if (has_host()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->host(), target);
  }

  // repeated uint32 clients = 2;
  for (int i = 0; i < this->clients_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->clients(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.RoomState)
  return target;
}

int RoomState::ByteSize() const {
  int total_size = 0;

  // required uint32 host = 1;
  if (has_host()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->host());
  }
  // repeated uint32 clients = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->clients_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->clients(i));
    }
    total_size += 1 * this->clients_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoomState::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RoomState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RoomState>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RoomState::MergeFrom(const RoomState& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  clients_.MergeFrom(from.clients_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host()) {
      set_host(from.host());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RoomState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoomState::CopyFrom(const RoomState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RoomState::Swap(RoomState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoomState::InternalSwap(RoomState* other) {
  std::swap(host_, other->host_);
  clients_.UnsafeArenaSwap(&other->clients_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoomState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoomState_descriptor_;
  metadata.reflection = RoomState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RoomState

// required uint32 host = 1;
bool RoomState::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RoomState::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
void RoomState::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
void RoomState::clear_host() {
  host_ = 0u;
  clear_has_host();
}
 ::google::protobuf::uint32 RoomState::host() const {
  // @@protoc_insertion_point(field_get:Tank.RoomState.host)
  return host_;
}
 void RoomState::set_host(::google::protobuf::uint32 value) {
  set_has_host();
  host_ = value;
  // @@protoc_insertion_point(field_set:Tank.RoomState.host)
}

// repeated uint32 clients = 2;
int RoomState::clients_size() const {
  return clients_.size();
}
void RoomState::clear_clients() {
  clients_.Clear();
}
 ::google::protobuf::uint32 RoomState::clients(int index) const {
  // @@protoc_insertion_point(field_get:Tank.RoomState.clients)
  return clients_.Get(index);
}
 void RoomState::set_clients(int index, ::google::protobuf::uint32 value) {
  clients_.Set(index, value);
  // @@protoc_insertion_point(field_set:Tank.RoomState.clients)
}
 void RoomState::add_clients(::google::protobuf::uint32 value) {
  clients_.Add(value);
  // @@protoc_insertion_point(field_add:Tank.RoomState.clients)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RoomState::clients() const {
  // @@protoc_insertion_point(field_list:Tank.RoomState.clients)
  return clients_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RoomState::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Tank.RoomState.clients)
  return &clients_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Message_ID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_ID_descriptor_;
}
bool Message_ID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 103:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Message_ID Message::UNKNOWN;
const Message_ID Message::LOGIN;
const Message_ID Message::ROOMSTATE;
const Message_ID Message::CHARACTERSTATE;
const Message_ID Message::ID_MIN;
const Message_ID Message::ID_MAX;
const int Message::ID_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Message_CharacterState_ActionID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_CharacterState_ActionID_descriptor_;
}
bool Message_CharacterState_ActionID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Message_CharacterState_ActionID Message_CharacterState::NONE;
const Message_CharacterState_ActionID Message_CharacterState::MOVEACTION;
const Message_CharacterState_ActionID Message_CharacterState::ROTATIONACTION;
const Message_CharacterState_ActionID Message_CharacterState::TURRETROTATIONACTION;
const Message_CharacterState_ActionID Message_CharacterState::FIREACTION;
const Message_CharacterState_ActionID Message_CharacterState::ActionID_MIN;
const Message_CharacterState_ActionID Message_CharacterState::ActionID_MAX;
const int Message_CharacterState::ActionID_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Message_CharacterState::kCharIDFieldNumber;
const int Message_CharacterState::kTimeFieldNumber;
const int Message_CharacterState::kActionFieldNumber;
const int Message_CharacterState::kPositionFieldNumber;
const int Message_CharacterState::kDirectionFieldNumber;
const int Message_CharacterState::kRotateFieldNumber;
const int Message_CharacterState::kCurspeedFieldNumber;
const int Message_CharacterState::kSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Message_CharacterState::Message_CharacterState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Message.CharacterState)
}

void Message_CharacterState::InitAsDefaultInstance() {
  position_ = const_cast< ::Tank::Vec3*>(&::Tank::Vec3::default_instance());
  direction_ = const_cast< ::Tank::Vec3*>(&::Tank::Vec3::default_instance());
  rotate_ = const_cast< ::Tank::Vec4*>(&::Tank::Vec4::default_instance());
}

Message_CharacterState::Message_CharacterState(const Message_CharacterState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Message.CharacterState)
}

void Message_CharacterState::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0u;
  time_ = 0;
  action_ = 0;
  position_ = NULL;
  direction_ = NULL;
  rotate_ = NULL;
  curspeed_ = 0;
  speed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Message_CharacterState::~Message_CharacterState() {
  // @@protoc_insertion_point(destructor:Tank.Message.CharacterState)
  SharedDtor();
}

void Message_CharacterState::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete direction_;
    delete rotate_;
  }
}

void Message_CharacterState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message_CharacterState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_CharacterState_descriptor_;
}

const Message_CharacterState& Message_CharacterState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Message_CharacterState* Message_CharacterState::default_instance_ = NULL;

Message_CharacterState* Message_CharacterState::New(::google::protobuf::Arena* arena) const {
  Message_CharacterState* n = new Message_CharacterState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Message_CharacterState::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Message_CharacterState*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(charid_, time_);
    ZR_(action_, curspeed_);
    if (has_position()) {
      if (position_ != NULL) position_->::Tank::Vec3::Clear();
    }
    if (has_direction()) {
      if (direction_ != NULL) direction_->::Tank::Vec3::Clear();
    }
    if (has_rotate()) {
      if (rotate_ != NULL) rotate_->::Tank::Vec4::Clear();
    }
    speed_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Message_CharacterState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Message.CharacterState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 charID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_time;
        break;
      }

      // required float time = 2;
      case 2: {
        if (tag == 21) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_action;
        break;
      }

      // required .Tank.Message.CharacterState.ActionID action = 3;
      case 3: {
        if (tag == 24) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Tank::Message_CharacterState_ActionID_IsValid(value)) {
            set_action(static_cast< ::Tank::Message_CharacterState_ActionID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_position;
        break;
      }

      // required .Tank.Vec3 position = 4;
      case 4: {
        if (tag == 34) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_direction;
        break;
      }

      // optional .Tank.Vec3 direction = 5;
      case 5: {
        if (tag == 42) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_rotate;
        break;
      }

      // optional .Tank.Vec4 rotate = 6;
      case 6: {
        if (tag == 50) {
         parse_rotate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rotate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_curspeed;
        break;
      }

      // optional float curspeed = 7;
      case 7: {
        if (tag == 61) {
         parse_curspeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &curspeed_)));
          set_has_curspeed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_speed;
        break;
      }

      // optional float speed = 8;
      case 8: {
        if (tag == 69) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Message.CharacterState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Message.CharacterState)
  return false;
#undef DO_
}

void Message_CharacterState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Message.CharacterState)
  // required uint32 charID = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->charid(), output);
  }

  // required float time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->time(), output);
  }

  // required .Tank.Message.CharacterState.ActionID action = 3;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->action(), output);
  }

  // required .Tank.Vec3 position = 4;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->position_, output);
  }

  // optional .Tank.Vec3 direction = 5;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->direction_, output);
  }

  // optional .Tank.Vec4 rotate = 6;
  if (has_rotate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->rotate_, output);
  }

  // optional float curspeed = 7;
  if (has_curspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->curspeed(), output);
  }

  // optional float speed = 8;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Message.CharacterState)
}

::google::protobuf::uint8* Message_CharacterState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Message.CharacterState)
  // required uint32 charID = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->charid(), target);
  }

  // required float time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->time(), target);
  }

  // required .Tank.Message.CharacterState.ActionID action = 3;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->action(), target);
  }

  // required .Tank.Vec3 position = 4;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->position_, target);
  }

  // optional .Tank.Vec3 direction = 5;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->direction_, target);
  }

  // optional .Tank.Vec4 rotate = 6;
  if (has_rotate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->rotate_, target);
  }

  // optional float curspeed = 7;
  if (has_curspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->curspeed(), target);
  }

  // optional float speed = 8;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Message.CharacterState)
  return target;
}

int Message_CharacterState::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_charid()) {
    // required uint32 charID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->charid());
  }

  if (has_time()) {
    // required float time = 2;
    total_size += 1 + 4;
  }

  if (has_action()) {
    // required .Tank.Message.CharacterState.ActionID action = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
  }

  if (has_position()) {
    // required .Tank.Vec3 position = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  return total_size;
}
int Message_CharacterState::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 charID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->charid());

    // required float time = 2;
    total_size += 1 + 4;

    // required .Tank.Message.CharacterState.ActionID action = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());

    // required .Tank.Vec3 position = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[4 / 32] & 240u) {
    // optional .Tank.Vec3 direction = 5;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->direction_);
    }

    // optional .Tank.Vec4 rotate = 6;
    if (has_rotate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rotate_);
    }

    // optional float curspeed = 7;
    if (has_curspeed()) {
      total_size += 1 + 4;
    }

    // optional float speed = 8;
    if (has_speed()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message_CharacterState::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Message_CharacterState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Message_CharacterState>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Message_CharacterState::MergeFrom(const Message_CharacterState& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_position()) {
      mutable_position()->::Tank::Vec3::MergeFrom(from.position());
    }
    if (from.has_direction()) {
      mutable_direction()->::Tank::Vec3::MergeFrom(from.direction());
    }
    if (from.has_rotate()) {
      mutable_rotate()->::Tank::Vec4::MergeFrom(from.rotate());
    }
    if (from.has_curspeed()) {
      set_curspeed(from.curspeed());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Message_CharacterState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message_CharacterState::CopyFrom(const Message_CharacterState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message_CharacterState::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_direction()) {
    if (!this->direction_->IsInitialized()) return false;
  }
  if (has_rotate()) {
    if (!this->rotate_->IsInitialized()) return false;
  }
  return true;
}

void Message_CharacterState::Swap(Message_CharacterState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Message_CharacterState::InternalSwap(Message_CharacterState* other) {
  std::swap(charid_, other->charid_);
  std::swap(time_, other->time_);
  std::swap(action_, other->action_);
  std::swap(position_, other->position_);
  std::swap(direction_, other->direction_);
  std::swap(rotate_, other->rotate_);
  std::swap(curspeed_, other->curspeed_);
  std::swap(speed_, other->speed_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Message_CharacterState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_CharacterState_descriptor_;
  metadata.reflection = Message_CharacterState_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Message::kCharacterstateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Message::Message()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Tank.Message)
}

void Message::InitAsDefaultInstance() {
  characterstate_ = const_cast< ::Tank::Message_CharacterState*>(&::Tank::Message_CharacterState::default_instance());
}

Message::Message(const Message& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Tank.Message)
}

void Message::SharedCtor() {
  _cached_size_ = 0;
  characterstate_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:Tank.Message)
  SharedDtor();
}

void Message::SharedDtor() {
  if (this != default_instance_) {
    delete characterstate_;
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_descriptor_;
}

const Message& Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Tank_2eproto();
  return *default_instance_;
}

Message* Message::default_instance_ = NULL;

Message* Message::New(::google::protobuf::Arena* arena) const {
  Message* n = new Message;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Message::Clear() {
  if (has_characterstate()) {
    if (characterstate_ != NULL) characterstate_->::Tank::Message_CharacterState::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Tank.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Tank.Message.CharacterState characterstate = 104;
      case 104: {
        if (tag == 834) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_characterstate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Tank.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Tank.Message)
  return false;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Tank.Message)
  // optional .Tank.Message.CharacterState characterstate = 104;
  if (has_characterstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      104, *this->characterstate_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Tank.Message)
}

::google::protobuf::uint8* Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tank.Message)
  // optional .Tank.Message.CharacterState characterstate = 104;
  if (has_characterstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        104, *this->characterstate_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tank.Message)
  return target;
}

int Message::ByteSize() const {
  int total_size = 0;

  // optional .Tank.Message.CharacterState characterstate = 104;
  if (has_characterstate()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->characterstate_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Message* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Message>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_characterstate()) {
      mutable_characterstate()->::Tank::Message_CharacterState::MergeFrom(from.characterstate());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {

  if (has_characterstate()) {
    if (!this->characterstate_->IsInitialized()) return false;
  }
  return true;
}

void Message::Swap(Message* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Message::InternalSwap(Message* other) {
  std::swap(characterstate_, other->characterstate_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_descriptor_;
  metadata.reflection = Message_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Message_CharacterState

// required uint32 charID = 1;
bool Message_CharacterState::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Message_CharacterState::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
void Message_CharacterState::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
void Message_CharacterState::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
 ::google::protobuf::uint32 Message_CharacterState::charid() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.charID)
  return charid_;
}
 void Message_CharacterState::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.charID)
}

// required float time = 2;
bool Message_CharacterState::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Message_CharacterState::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
void Message_CharacterState::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
void Message_CharacterState::clear_time() {
  time_ = 0;
  clear_has_time();
}
 float Message_CharacterState::time() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.time)
  return time_;
}
 void Message_CharacterState::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.time)
}

// required .Tank.Message.CharacterState.ActionID action = 3;
bool Message_CharacterState::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Message_CharacterState::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
void Message_CharacterState::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
void Message_CharacterState::clear_action() {
  action_ = 0;
  clear_has_action();
}
 ::Tank::Message_CharacterState_ActionID Message_CharacterState::action() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.action)
  return static_cast< ::Tank::Message_CharacterState_ActionID >(action_);
}
 void Message_CharacterState::set_action(::Tank::Message_CharacterState_ActionID value) {
  assert(::Tank::Message_CharacterState_ActionID_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.action)
}

// required .Tank.Vec3 position = 4;
bool Message_CharacterState::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Message_CharacterState::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
void Message_CharacterState::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
void Message_CharacterState::clear_position() {
  if (position_ != NULL) position_->::Tank::Vec3::Clear();
  clear_has_position();
}
const ::Tank::Vec3& Message_CharacterState::position() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::Tank::Vec3* Message_CharacterState::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Tank::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.position)
  return position_;
}
::Tank::Vec3* Message_CharacterState::release_position() {
  clear_has_position();
  ::Tank::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
void Message_CharacterState::set_allocated_position(::Tank::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.position)
}

// optional .Tank.Vec3 direction = 5;
bool Message_CharacterState::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Message_CharacterState::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
void Message_CharacterState::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
void Message_CharacterState::clear_direction() {
  if (direction_ != NULL) direction_->::Tank::Vec3::Clear();
  clear_has_direction();
}
const ::Tank::Vec3& Message_CharacterState::direction() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
::Tank::Vec3* Message_CharacterState::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::Tank::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.direction)
  return direction_;
}
::Tank::Vec3* Message_CharacterState::release_direction() {
  clear_has_direction();
  ::Tank::Vec3* temp = direction_;
  direction_ = NULL;
  return temp;
}
void Message_CharacterState::set_allocated_direction(::Tank::Vec3* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.direction)
}

// optional .Tank.Vec4 rotate = 6;
bool Message_CharacterState::has_rotate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Message_CharacterState::set_has_rotate() {
  _has_bits_[0] |= 0x00000020u;
}
void Message_CharacterState::clear_has_rotate() {
  _has_bits_[0] &= ~0x00000020u;
}
void Message_CharacterState::clear_rotate() {
  if (rotate_ != NULL) rotate_->::Tank::Vec4::Clear();
  clear_has_rotate();
}
const ::Tank::Vec4& Message_CharacterState::rotate() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.rotate)
  return rotate_ != NULL ? *rotate_ : *default_instance_->rotate_;
}
::Tank::Vec4* Message_CharacterState::mutable_rotate() {
  set_has_rotate();
  if (rotate_ == NULL) {
    rotate_ = new ::Tank::Vec4;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.CharacterState.rotate)
  return rotate_;
}
::Tank::Vec4* Message_CharacterState::release_rotate() {
  clear_has_rotate();
  ::Tank::Vec4* temp = rotate_;
  rotate_ = NULL;
  return temp;
}
void Message_CharacterState::set_allocated_rotate(::Tank::Vec4* rotate) {
  delete rotate_;
  rotate_ = rotate;
  if (rotate) {
    set_has_rotate();
  } else {
    clear_has_rotate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.CharacterState.rotate)
}

// optional float curspeed = 7;
bool Message_CharacterState::has_curspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Message_CharacterState::set_has_curspeed() {
  _has_bits_[0] |= 0x00000040u;
}
void Message_CharacterState::clear_has_curspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
void Message_CharacterState::clear_curspeed() {
  curspeed_ = 0;
  clear_has_curspeed();
}
 float Message_CharacterState::curspeed() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.curspeed)
  return curspeed_;
}
 void Message_CharacterState::set_curspeed(float value) {
  set_has_curspeed();
  curspeed_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.curspeed)
}

// optional float speed = 8;
bool Message_CharacterState::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Message_CharacterState::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
void Message_CharacterState::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
void Message_CharacterState::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float Message_CharacterState::speed() const {
  // @@protoc_insertion_point(field_get:Tank.Message.CharacterState.speed)
  return speed_;
}
 void Message_CharacterState::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Tank.Message.CharacterState.speed)
}

// -------------------------------------------------------------------

// Message

// optional .Tank.Message.CharacterState characterstate = 104;
bool Message::has_characterstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Message::set_has_characterstate() {
  _has_bits_[0] |= 0x00000001u;
}
void Message::clear_has_characterstate() {
  _has_bits_[0] &= ~0x00000001u;
}
void Message::clear_characterstate() {
  if (characterstate_ != NULL) characterstate_->::Tank::Message_CharacterState::Clear();
  clear_has_characterstate();
}
const ::Tank::Message_CharacterState& Message::characterstate() const {
  // @@protoc_insertion_point(field_get:Tank.Message.characterstate)
  return characterstate_ != NULL ? *characterstate_ : *default_instance_->characterstate_;
}
::Tank::Message_CharacterState* Message::mutable_characterstate() {
  set_has_characterstate();
  if (characterstate_ == NULL) {
    characterstate_ = new ::Tank::Message_CharacterState;
  }
  // @@protoc_insertion_point(field_mutable:Tank.Message.characterstate)
  return characterstate_;
}
::Tank::Message_CharacterState* Message::release_characterstate() {
  clear_has_characterstate();
  ::Tank::Message_CharacterState* temp = characterstate_;
  characterstate_ = NULL;
  return temp;
}
void Message::set_allocated_characterstate(::Tank::Message_CharacterState* characterstate) {
  delete characterstate_;
  characterstate_ = characterstate;
  if (characterstate) {
    set_has_characterstate();
  } else {
    clear_has_characterstate();
  }
  // @@protoc_insertion_point(field_set_allocated:Tank.Message.characterstate)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Tank

// @@protoc_insertion_point(global_scope)
